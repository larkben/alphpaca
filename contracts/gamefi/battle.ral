struct PacaFlip {active: ByteVec, waiting: ByteVec}

Contract PvpBattle(
    // pvp players
    owner: Address,
    alphpacaOwner: ByteVec,
    mut challenger: Address,
    mut alphpacaChallenger: ByteVec,
    // utils
    mut isActive: Bool,
    mut turn: Bool,                 // true = owner, false = challenger
    mut battleFinished: Bool,
    mut timeSinceLastMove: U256,
    // wagered assets
    wageredAsset: ByteVec,
    mut wageredAmount: U256,
    oracle: IDIAOracle              // oracle integration
) extends BattleTools(oracle) {
                                    // important to add a time component / forfeit options
                                    // reward mechanism / prevent spoofing (spin a bale for chance (0.1 alph) 50% chance)

    enum Codes {
        PvpNotActive = 0
        NotYourTurn = 1
        BattleFinished = 2
        TimeLimitExceeded = 3
    }

    fn checkTurn(caller: Address) -> () {
        if (turn == false) {
            assert!(caller == challenger, Codes.NotYourTurn)
        }
        else {
            assert!(caller == owner, Codes.NotYourTurn)
        }
    }

    fn whichPaca() -> PacaFlip {
        if (turn == false) {
            let c = PacaFlip {active: alphpacaChallenger, waiting: alphpacaOwner}
            return c
        }
        else {
            let o = PacaFlip {active: alphpacaOwner, waiting: alphpacaChallenger}
            return o
        }
    }

    @using(checkExternalCaller = false, updateFields = true, preapprovedAssets = true)
    pub fn acceptBattle(who: Address, alphpaca: ByteVec) -> () {
        assert!(isActive == false, Codes.PvpNotActive)

        challenger = who                      // assigns challenger
        alphpacaChallenger = alphpaca

        isActive = true                       // the battle is marked as started
        turn =  false                         // challenger goes first

        transferToken!(callerAddress!(), selfAddress!(), wageredAsset, wageredAmount)

                                              // challenger and their bet is added to pool
        wageredAmount = wageredAmount * 2

        timeSinceLastMove = blockTimeStamp!() // the battle has begun
    }

    @using(checkExternalCaller = false, updateFields = true)    // need to figure out how to integrate moves into chance
    pub fn attack(who: Address, move: ByteVec) -> () {
        assert!(isActive == true, Codes.PvpNotActive)
        assert!(battleFinished == false, Codes.BattleFinished)

        let deltaTime = blockTimeStamp!() - timeSinceLastMove   // deltaTime  

        assert!(deltaTime < 172800000, Codes.TimeLimitExceeded)

        checkTurn(who)

        let moveStats = Move(move).performMove()

        let paca = whichPaca()

        let damage = damageFormula(
            Player(paca.active).getLevel(), 
            moveStats.a, 
            Player(paca.active).getAttackStat(),
            Player(paca.waiting).getDefense()
        )

        let status = Player(paca.waiting).removeHealth(damage)

        if (status == false) {
            battleFinished = true
        } else {
            // paca is still alive
            turn = !turn
        }
    }

    // forfeit options - player may not want to continue (therefore this clause exists)
    pub fn forfeit() -> () {
        
    }
}