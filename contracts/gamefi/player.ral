import "std/nft_interface"

Contract Player(
  // basic params
  nftIndex: U256,
  mut tokenUri: ByteVec,    // allows the tokenUri to be edited
  collectionId: ByteVec,
  // the paca functionality suite
  mut nickname: ByteVec,
  mut linkedAddress: Address,
  // stats
  mut stats: [U256; 4],     // health, attack, defense, xp
  // item held (hay)
  mut hay: ByteVec,         // this equipped item is meant to increase 1/3 skills by a factor of * at the cost of another
  // bound move - we will call an NFT with this particular move and if called then the nft
  // calls a function to checkLinked nft and then asserts, moves will cause bonuses and or defects
  mut moves: [ByteVec; 4]
) implements INFT {
  enum ErrorCodes {
    NotCalledFromCollection = 0
    InvalidSkill = 1
  }

  pub fn getTokenUri() -> ByteVec {
    return tokenUri
  }

  pub fn getNFTIndex() -> U256 {
    return nftIndex
  }

  pub fn getCollectionIndex() -> (ByteVec, U256) {
    return collectionId, nftIndex
  }

  @using(checkExternalCaller = true, updateFields = true)
  pub fn editUri(newUri: ByteVec) -> () {
    let addressCalled = contractIdToAddress!(collectionId)

    checkCaller!(callerAddress!() == addressCalled, ErrorCodes.NotCalledFromCollection)
    tokenUri = newUri
  }

  // Decentralized Naming Feature
  @using(checkExternalCaller = true, updateFields = true)
  pub fn editNick(newNick: ByteVec) -> () {
    let addressCalled = contractIdToAddress!(collectionId)

    checkCaller!(callerAddress!() == addressCalled, ErrorCodes.NotCalledFromCollection)
    nickname = newNick
  }

  @using(checkExternalCaller = true, updateFields = true)
  pub fn editLinkedAddress(newAddress: Address) -> () {
    let addressCalled = contractIdToAddress!(collectionId)

    checkCaller!(callerAddress!() == addressCalled, ErrorCodes.NotCalledFromCollection)
    linkedAddress = newAddress
  }

  // Assign Moves - maybe a better data structure for the moveSets
  @using(checkExternalCaller = true, updateFields = true)
  pub fn assignMoveOne(move: ByteVec) -> () {
    let addressCalled = contractIdToAddress!(collectionId)

    checkCaller!(callerAddress!() == addressCalled, ErrorCodes.NotCalledFromCollection)
    
    // check that nft id has a linked function called checkLink to the nft id of this nft

    moveOne = move
  }

  // Upgrade Skills
  pub fn upgradeSkill(whichSkill: U256) -> () {
    
    assert!(whichSkill <= 3, Error.InvalidSkill)

    let difficulty = (stats[whichSkill] * 1) / 2 // (statsValue * 1) / 2
  }
}