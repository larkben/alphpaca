import "std/nft_collection_interface"

Contract PlayerBase(
    collectionOwner: Address,
    mut collectionUri: ByteVec,
    mut totalSupply: U256,
    alphpacaId: ByteVec,
    parentContractId: ByteVec,
    baseuri: ByteVec,
    playerContractId: ByteVec
) implements INFTCollection {
    event Mint(minter: Address, fromIndex: U256)

    enum ErrorCodes {
        NFTNotFound = 0
        CollectionOwnerAllowedOnly = 1
        NFTNotPartOfCollection = 2
        NotCalledFromGame = 3
    }

    pub fn getCollectionUri() -> ByteVec {
        return collectionUri
    }

    pub fn totalSupply() -> U256 {
        return totalSupply
    }

    @using(checkExternalCaller = false)
    pub fn nftByIndex(index: U256) -> INFT {
        let nftTokenId = subContractId!(toByteVec!(index))
        assert!(contractExists!(nftTokenId), ErrorCodes.NFTNotFound)

        return INFT(nftTokenId)
    }

    @using(assetsInContract = true)
    pub fn withdraw(to: Address, amount: U256) -> () {
        checkCaller!(callerAddress!() == collectionOwner, ErrorCodes.CollectionOwnerAllowedOnly)
        transferTokenFromSelf!(to, ALPH, amount)
    }

    @using(assetsInContract = true)
    pub fn withdrawNonNative(to: Address, token: ByteVec, amount: U256) -> () {
        checkCaller!(callerAddress!() == collectionOwner, ErrorCodes.CollectionOwnerAllowedOnly)
        
        transferTokenFromSelf!(to, token, amount)
    }

    // validation ? ~ not being used
    @using(checkExternalCaller = false)
    pub fn validateNFT(nftId: ByteVec, index: U256) -> () {
      let expectedTokenContract = nftByIndex(index)
      assert!(nftId == contractId!(expectedTokenContract), ErrorCodes.NFTNotPartOfCollection)
    }

    // mint player
    @using(preapprovedAssets = true)
    pub fn mint(tokenSelected: ByteVec, index: U256) -> () {

        burnToken!(callerAddress!(), tokenSelected, 1)

        let nftIndex = index

        // gets the index of the selected nft and then sets to the index of the new nft
        let nftUri = baseuri ++ u256ToString!(index)

        let c = #

        let (encodeImmutableFields, encodeMutableFields) = Player.encodeFields!(nftIndex, nftUri, selfContractId!(), c, callerAddress!())

        let contractId = copyCreateSubContractWithToken!{callerAddress!() -> ALPH: minimalContractDeposit!()}(
            toByteVec!(nftIndex),
            playerContractId,
            encodeImmutableFields,
            encodeMutableFields,
            1,
            callerAddress!()
        )

        totalSupply = totalSupply + 1

        emit Mint(callerAddress!(), nftIndex)
    }

    // edit
    @using(checkExternalCaller = true)
    pub fn editCollectionUri(newCollectionUri: ByteVec) -> () {
        checkCaller!(callerAddress!() == collectionOwner, ErrorCodes.CollectionOwnerAllowedOnly)

        collectionUri = newCollectionUri
    }

    // upgrades
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updatePlayerBase(newCode: ByteVec) -> () {
        checkCaller!(callerAddress!() == collectionOwner, ErrorCodes.CollectionOwnerAllowedOnly)

        migrate!(newCode)
    }

    @using(checkExternalCaller = true, updateFields = true)
    pub fn updatePlayerBaseFields(newCode: ByteVec, newImmFieldsEncoded: ByteVec, newMutFieldsEncoded: ByteVec) -> () {
        checkCaller!(callerAddress!() == collectionOwner, ErrorCodes.CollectionOwnerAllowedOnly)

        migrateWithFields!(newCode, newImmFieldsEncoded, newMutFieldsEncoded)
    }
}