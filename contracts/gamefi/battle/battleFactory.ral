Contract BattleFactory(
    admin: Address,
    pvp: ByteVec,
    oracle: IDIAOracle,
    gameFi: ByteVec,
    // reward flow
    token: ByteVec,
    mut tokenAmount: U256
) {
    event BattleCreate(nftOne: ByteVec, creator: Address, wagerToken: ByteVec, wager: U256)
    event BattleStart(nftOne: ByteVec, nftTwo: ByteVec, reward: U256, hpOne: U256, hpTwo: U256)
    event BattleEnd(nftOne: ByteVec, nftTwo: ByteVec, winner: ByteVec)

    enum BattleFactoryErrorCodes {
        NotAdmin = 0
        NotSupercharged = 1
    }

    // helper functions
    // --------------------------------------------------------------------------------------------
    fn isSupercharged(nft: ByteVec) -> Bool {
        // returns a boolean
        return GamifyProtocol(gameFi).isSupercharged(nft)
    }

    // variable amount of PACA
    fn assignReward() -> U256 {
        let seed = u256From32Byte!(
            blake2b!(toByteVec!(blockTarget!()) ++ 
            toByteVec!(blockTimeStamp!()) ++
            toByteVec!(oracle.getValue(b`BTC/USD`).value))
        )
        return addModN!(50, seed, 150)
    }

    // contract functions
    // --------------------------------------------------------------------------------------------
    // notes:
    // battle take place on land plots? ~ could be sorta cool I think
    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createBattle(nft: ByteVec, wagerToken: ByteVec, amount: U256) -> () {
        // assert the nft has been through gameFi
        assert!(isSupercharged(nft) == true, BattleFactoryErrorCodes.NotSupercharged)

        // value declaration
        let path = nft
        let nullToken = b``

        let (encodeImmutableFields, encodeMutableFields) = Battle.encodeFields!(callerAddress!(), nft, wagerToken, amount, callerAddress!(), nullToken, 1, oracle, gameFi, 0)

        // APS!
        let battleId = createSubContract!{callerAddress!() -> ALPH: minimalContractDeposit!(), nft: 1, wagerToken: amount} 
        (
            path,   // use the owners nft as the path to the subContract
            pvp,
            encodeImmutableFields,
            encodeMutableFields
        )

        // emit the event
        emit BattleCreate(nft, callerAddress!(), wagerToken, amount)
    }

    @using(checkExternalCaller = false, preapprovedAssets = true)
    pub fn start(nft: ByteVec, opponent: ByteVec) -> () {
        // assert the nft has been through gameFi
        assert!(isSupercharged(nft) == true, BattleFactoryErrorCodes.NotSupercharged)

        // declare the subContract
        let battle = Battle(subContractId!(opponent))

        // get reward
        let wagerToken = battle.getWagerToken() 
        let amount = battle.getWagerAmount()

        let reward = assignReward()

        // get stats
        let nftOne = GamifyProtocol(gameFi).getNFTstats(nft)
        let nftTwo = GamifyProtocol(gameFi).getNFTstats(opponent)

        // make call to the subContract
        battle.acceptBattle{callerAddress!() -> nft: 1, wagerToken: amount}(nft, callerAddress!())

        // emit the event ~ reward is assigned at runtime (oracle)
        emit BattleStart(nft, opponent, reward, nftOne.hp, nftTwo.hp)
    }

    @using(checkExternalCaller = false)
    pub fn attack(contractId: ByteVec) -> () {
        let battle = Battle(contractId)

        battle.attack()
    }

    @using(checkExternalCaller = false)
    pub fn end(contractId: ByteVec) -> () {
        let battle = Battle(contractId)

        battle.endbattle()
    }

    @using(checkExternalCaller = false)
    pub fn leavebattle(contractId: ByteVec) -> () {
        let battle = Battle(contractId)

        battle.leave()
    }

    @using(checkExternalCaller = false)
    pub fn cancel(contractId: ByteVec) -> () {
        let battle = Battle(contractId)

        battle.cancel()

        // emit the event
    }

    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true)
    pub fn fund(who: Address, token: ByteVec, amount: U256, topup: Bool) -> () {
        checkCaller!(callerAddress!() == admin, BattleFactoryErrorCodes.NotAdmin)

        if (topup) {
            transferToken!(callerAddress!(), selfAddress!(), token, tokenAmount)

            tokenAmount = tokenAmount + amount
        }

        else {
            transferToken!(selfAddress!(), callerAddress!(), token, tokenAmount)
        }
    }

    @using(checkExternalCaller = true)
    pub fn upgrade(newCode: ByteVec) -> () {
        checkCaller!(callerAddress!() == admin, BattleFactoryErrorCodes.NotAdmin)

        migrate!(newCode)
    }

    @using(checkExternalCaller = true, updateFields = true)
    pub fn upgradeFields(newCode: ByteVec, immutable: ByteVec, mutable: ByteVec) -> () {
        checkCaller!(callerAddress!() == admin, BattleFactoryErrorCodes.NotAdmin)

        migrateWithFields!(newCode, immutable, mutable)
    }

}

TxScript CreatePvp (
    market: FindBattle,
    paca: ByteVec
) {
    market.createBattle{callerAddress!() -> ALPH: minimalContractDeposit!()}(paca)
}

TxScript Start (
    market: FindBattle,
    contractId: ByteVec,
    paca: ByteVec
) {
    market.start(contractId, paca)
}

TxScript Attack (
    market: FindBattle,
    contractId: ByteVec
) {
    market.attack(contractId)
}

TxScript End (
    market: FindBattle,
    contractId: ByteVec
) {
    market.end(contractId)
}

TxScript LeaveBattle (
    market: FindBattle,
    contractId: ByteVec
) {
    market.leavebattle(contractId)
}

TxScript Cancel (
    market: FindBattle,
    contractId: ByteVec
) {
    market.cancel(contractId)
}

// upgrades

TxScript UpgradeFindBattle (
    market: FindBattle,
    newCode: ByteVec
) {
    market.upgrade(newCode)
}

TxScript UpgradeFindBattleWithFields (
    market: FindBattle,
    newCode: ByteVec,
    immutable: ByteVec,
    mutable: ByteVec
) {
    market.upgradeFields(newCode, immutable, mutable)
}