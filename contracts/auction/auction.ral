//
// |----| |----| |---| |----|
// |    | |    | |     |    |
// |----| |----| |     |----|
// |      |    | |---| |    |
//
// A project built by the OG PACA. ðŸ¦™
//

Contract Auction (
    token: ByteVec,
    amount: U256,
    mut time: U256,
    increment: U256,
    mut bid: U256,
    mut owner: Address,
    creator: Address,
    factory: Address
) {
    event Bid(contract: ByteVec, newbid: Amount, newtime: U256, address: Address)

    enum ErrorCodes {
        InvalidCaller = 1
        AuctionEnded = 2
        AuctionInProgress = 3
    }

    pub fn getToken() -> ByteVec {
        return token
    }

    pub fn getAmount() -> U256 {
        return amount
    }

    pub fn getTime() -> U256 {
        return time
    }

    pub fn getIncrement() -> U256 {
        return increment
    }

    pub fn getBid() -> U256 {
        return bid
    }

    pub fn getOwner() -> Address {
        return owner
    }

    pub fn getCreator() -> Address {
        return creator
    }

    pub fn getFactory() -> Address {
        return address
    }

    pub fn makebid() -> () {

        assert!(blockTimeStamp!() < time, ErrorCodes.AuctionEnded)

        if (getOwner() == getCreator()) {
            transferToken!(callerAddress!(), selfAddress!(), ALPH, getBid())       // collect assets from bidder
        }
        else {
            transferToken!(selfAddress!(), getOwner(), ALPH, getBid() - increment) // subtract the increment from the previous bid

            transferToken!(callerAddress!(), selfAddress!(), ALPH, getBid())       // new bidder now becomes owner
        }

        bid = bid + increment                                                      // update bid

        owner = callerAddress!()                                                   // update owner who is now highest bidder

        let deltatime = time - blockTimeStamp!()                                   // calculate delta time

        // if less than a minute left but recieves a bid the timer adds a minute to the auction
        if (deltatime < 60000) {
            time = time + 60000    
        }
    }

    pub fn claimreward() -> () {
        let fee = (getBid() - increment) * 5 / 100; 

        assert!(blockTimeStamp!() > time, ErrorCodes.AuctionInProgress)

        transferToken!(selfAddress!(), getOwner(), getToken(), getAmount())       // sends out token to winner

        let delta = increment + fee

        transferToken!(selfAddress!(), getFactory(), ALPH, fee)

        transferToken!(selfAddress!(), getCreator(), ALPH, getBid() - delta)

        destroySelf!(getCreator())                                                // creator gets deposit alph back
    }

    pub fn claimalph() -> () {
        // calculate 5% fee

        let fee = (getBid() - increment) * 5 / 100;                              // Calculate 5% fee based on ALPH winnings

        assert!(blockTimeStamp!() > time, ErrorCodes.AuctionInProgress)

        transferToken!(selfAddress!(), getOwner(), getToken(), getAmount())      // sends out token to winner

        assert!(callerAddress!() == getCreator(), ErrorCodes.InvalidCaller)

        let delta = increment + fee

        transferToken!(selfAddress!(), getFactory(), ALPH, fee)

        transferToken!(selfAddress!(), getCreator(), ALPH, getBid() - delta)     // creator gets alph winnings - 5% fee

        destroySelf!(creator)

    }
}