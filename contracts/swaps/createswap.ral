// Protocol Contract, Fractional Contracts

Contract Market (
    owner: Address,
    // Swap Contract
    swapcontract: ByteVec,
    totalswaps: U256,
    // Auction Contract
    auctioncontract: ByteVec,
    // Loan Contract
    loancontract: ByteVec,
    // Tokens (FEES)
    paca: ByteVec, 
    // Fees associated with contract creation
    mut pacafee: U256,
    mut alphfee: U256,
    // Variables used for fee collection
    mut ownedalph: U256,
    mut ownedpaca: U256
) {
    // Events
    // feetype -> 1 FOR ALPH, 2 FOR PACA

    // Events
    event Swap(type: U256, feetype: U256 tokeno: ByteVec, amto: U256, tokenw: ByteVec, amtw: U256, contract: ByteVec, address: Address) // Type 1
    event Auction(type: U256 tokeno: ByteVec, amto: U256, tokenw: ByteVec, amtw: U256, incrtoken: ByteVec, increment: U256, contract: ByteVec, address: Address) // Type 2
    event Loan(type: U256 tokeno: ByteVec, amto: U256, tokenw: ByteVec, amtw: U256, contract: ByteVec, address: Address) // Type 3

    event FeeChange(feetype: U256, newfee: U256)

    // Error Codes
    enum ErrorCodes {
        InvalidCaller = 1
    }

    // Public Functions
    pub fn getTokenId() -> ByteVec {
        return paca
    }

    pub fn getPacaFee() -> U256 {
        return pacafee
    }

    pub fn getAlphFee() -> U256 {
        return alphfee
    }

    pub fn getPacaToken() -> ByteVec {
        return paca
    }

    @using(preapprovedAssets = true, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    pub fn createswap(type: U256, tokenOffered: ByteVec, tokenOfferedAmt: U256, tokenWanted: ByteVec, tokenWantedAmt: U256) -> () { // if 1, then use ALPH, if 2 then use PACA
        
        let minter = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Swap.encodeFields!(tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, minter)

        let contractID = copyCreateSubContract!{minter -> ALPH: 1 alph, tokenOffered: tokenOfferedAmt}(
            toByteVec!(totalswaps)
            contract,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        totalswaps = totalswaps + 1

        if (type == 1) {
            transferToken!(minter, owner, ALPH, getAlphFee())
            ownedalph = ownedalph + getAlphFee()
        }
        else {
            transferToken!(minter, owner, getPacaToken(), getPacaFee())
            ownedpaca = ownedpaca + getPacaFee()
        }

        emit Swap(1, type, tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, contractID, contractIdToAddress!(contractID))
    }

    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = true)
    pub fn feepaca(amount: U256) -> () {

        checkCaller!(callerAddress!() == owner, ErrorCodes.InvalidCaller)

        pacafee = amount

        emit FeeChange(2, pacafee)
    }

    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = true)
    pub fn feealph(amount: U256) -> () {

        checkCaller!(callerAddress!() == owner, ErrorCodes.InvalidCaller)
        
        alphfee = amount

        emit FeeChange(1, alphfee)
    }

    @using(preapprovedAssets = false, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn collectfees() -> () {

        assert!(owner == callerAddress!(), ErrorCodes.InvalidCaller)
        
        transferTokenFromSelf!(owner, getPacaToken(), ownedpaca)

        transferTokenFromSelf!(owner, ALPH, ownedalph)

        ownedpaca = 0
        ownedalph = 0
    }

    @using(assetsInContract = true, updateFields = false, checkExternalCaller = true)
    pub fn destroytokenswap() -> () {

        let caller = callerAddress!()

        checkCaller!(owner == caller, ErrorCodes.InvalidCaller)

        destroySelf!(owner)

        emit Destroy(owner)
    }

}