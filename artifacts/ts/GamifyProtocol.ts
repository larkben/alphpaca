/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  Asset,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
  SignExecuteContractMethodParams,
  SignExecuteScriptTxResult,
  signExecuteMethod,
  addStdIdToFields,
  encodeContractFields,
  Narrow,
} from "@alephium/web3";
import { default as GamifyProtocolContractJson } from "../gamefi/GamifyProtocol.ral.json";
import { getContractByCodeHash, registerContract } from "./contracts";
import {
  DIAOracleValue,
  PairInfo,
  PlayerData,
  TokenData,
  AllStructs,
} from "./types";
import { RalphMap } from "@alephium/web3";

// Custom types for the contract
export namespace GamifyProtocolTypes {
  export type Fields = {
    admin: Address;
    supercharged: bigint;
    pacaToken: HexString;
    pacaAmount: bigint;
    xpRate: bigint;
  };

  export type State = ContractState<Fields>;

  export type SuperchargeEvent = ContractEvent<{
    who: Address;
    nft: HexString;
    time: bigint;
  }>;
  export type UpdateEvent = ContractEvent<{ who: Address; nft: HexString }>;

  export interface CallMethodTable {
    getNFTstats: {
      params: CallContractParams<{ nft: HexString }>;
      result: CallContractResult<PlayerData>;
    };
    isSupercharged: {
      params: CallContractParams<{ nft: HexString }>;
      result: CallContractResult<boolean>;
    };
    supercharge: {
      params: CallContractParams<{ nft: HexString }>;
      result: CallContractResult<null>;
    };
    updateLevel: {
      params: CallContractParams<{ nft: HexString; index: bigint }>;
      result: CallContractResult<null>;
    };
    rest: {
      params: CallContractParams<{ nft: HexString; quickRest: boolean }>;
      result: CallContractResult<null>;
    };
    removeHealth: {
      params: CallContractParams<{ nft: HexString; damage: bigint }>;
      result: CallContractResult<bigint>;
    };
    addXp: {
      params: CallContractParams<{
        nft: HexString;
        xp: bigint;
        paidXp: boolean;
      }>;
      result: CallContractResult<null>;
    };
    editValidContract: {
      params: CallContractParams<{ contract: HexString; remove: boolean }>;
      result: CallContractResult<null>;
    };
    rewardPaca: {
      params: CallContractParams<{ reward: bigint; reciever: Address }>;
      result: CallContractResult<null>;
    };
    updateGamifyCode: {
      params: CallContractParams<{ newCode: HexString }>;
      result: CallContractResult<null>;
    };
    updateGamifyFields: {
      params: CallContractParams<{
        newCode: HexString;
        immFields: HexString;
        mutFields: HexString;
      }>;
      result: CallContractResult<null>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
      ? CallMethodTable[MaybeName]["result"]
      : undefined;
  };
  export type MulticallReturnType<Callss extends MultiCallParams[]> = {
    [index in keyof Callss]: MultiCallResults<Callss[index]>;
  };

  export interface SignExecuteMethodTable {
    getNFTstats: {
      params: SignExecuteContractMethodParams<{ nft: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    isSupercharged: {
      params: SignExecuteContractMethodParams<{ nft: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    supercharge: {
      params: SignExecuteContractMethodParams<{ nft: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    updateLevel: {
      params: SignExecuteContractMethodParams<{
        nft: HexString;
        index: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    rest: {
      params: SignExecuteContractMethodParams<{
        nft: HexString;
        quickRest: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    removeHealth: {
      params: SignExecuteContractMethodParams<{
        nft: HexString;
        damage: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    addXp: {
      params: SignExecuteContractMethodParams<{
        nft: HexString;
        xp: bigint;
        paidXp: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    editValidContract: {
      params: SignExecuteContractMethodParams<{
        contract: HexString;
        remove: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    rewardPaca: {
      params: SignExecuteContractMethodParams<{
        reward: bigint;
        reciever: Address;
      }>;
      result: SignExecuteScriptTxResult;
    };
    updateGamifyCode: {
      params: SignExecuteContractMethodParams<{ newCode: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    updateGamifyFields: {
      params: SignExecuteContractMethodParams<{
        newCode: HexString;
        immFields: HexString;
        mutFields: HexString;
      }>;
      result: SignExecuteScriptTxResult;
    };
  }
  export type SignExecuteMethodParams<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["params"];
  export type SignExecuteMethodResult<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["result"];

  export type Maps = {
    supernfts?: Map<HexString, PlayerData>;
    collections?: Map<HexString, boolean>;
    approved?: Map<Address, boolean>;
  };
}

class Factory extends ContractFactory<
  GamifyProtocolInstance,
  GamifyProtocolTypes.Fields
> {
  encodeFields(fields: GamifyProtocolTypes.Fields) {
    return encodeContractFields(
      addStdIdToFields(this.contract, fields),
      this.contract.fieldsSig,
      AllStructs
    );
  }

  eventIndex = { Supercharge: 0, Update: 1 };
  consts = {
    GamifyCodes: {
      AlreadySupercharged: BigInt("0"),
      NotAdmin: BigInt("1"),
      NotSupercharged: BigInt("2"),
      NotApprovedContract: BigInt("3"),
      NotEnoughXp: BigInt("4"),
      NotApprovedNFT: BigInt("5"),
    },
  };

  at(address: string): GamifyProtocolInstance {
    return new GamifyProtocolInstance(address);
  }

  tests = {
    getNFTstats: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { nft: HexString },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<PlayerData, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "getNFTstats", params, getContractByCodeHash);
    },
    isSupercharged: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { nft: HexString },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<boolean, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "isSupercharged", params, getContractByCodeHash);
    },
    supercharge: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { nft: HexString },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "supercharge", params, getContractByCodeHash);
    },
    updateLevel: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { nft: HexString; index: bigint },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "updateLevel", params, getContractByCodeHash);
    },
    rest: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { nft: HexString; quickRest: boolean },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "rest", params, getContractByCodeHash);
    },
    removeHealth: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { nft: HexString; damage: bigint },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<bigint, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "removeHealth", params, getContractByCodeHash);
    },
    addXp: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { nft: HexString; xp: bigint; paidXp: boolean },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "addXp", params, getContractByCodeHash);
    },
    editValidContract: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { contract: HexString; remove: boolean },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(
        this,
        "editValidContract",
        params,
        getContractByCodeHash
      );
    },
    rewardPaca: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { reward: bigint; reciever: Address },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(this, "rewardPaca", params, getContractByCodeHash);
    },
    updateGamifyCode: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { newCode: HexString },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(
        this,
        "updateGamifyCode",
        params,
        getContractByCodeHash
      );
    },
    updateGamifyFields: async (
      params: TestContractParams<
        GamifyProtocolTypes.Fields,
        { newCode: HexString; immFields: HexString; mutFields: HexString },
        GamifyProtocolTypes.Maps
      >
    ): Promise<TestContractResult<null, GamifyProtocolTypes.Maps>> => {
      return testMethod(
        this,
        "updateGamifyFields",
        params,
        getContractByCodeHash
      );
    },
  };

  stateForTest(
    initFields: GamifyProtocolTypes.Fields,
    asset?: Asset,
    address?: string,
    maps?: GamifyProtocolTypes.Maps
  ) {
    return this.stateForTest_(initFields, asset, address, maps);
  }
}

// Use this object to test and deploy the contract
export const GamifyProtocol = new Factory(
  Contract.fromJson(
    GamifyProtocolContractJson,
    "=14-2+9b=2-2+60=2-2+2e=2-1=1-4+7=2-2+a5=3-1+a=2-1+5b=1+56f=2-2+87=425-1+9=266+7a7e0214696e73657274206174206d617020706174683a2000=1647-1+e=29-1+c=36+7a7e0214696e73657274206174206d617020706174683a2000=13-1+a=36+7a7e021472656d6f7665206174206d617020706174683a2000=224",
    "069c4f18450971a6aa7e08b08ca1fff9ba632ffdc2c19fbb96fdbe6d43e5e357",
    AllStructs
  )
);
registerContract(GamifyProtocol);

// Use this class to interact with the blockchain
export class GamifyProtocolInstance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  maps = {
    supernfts: new RalphMap<HexString, PlayerData>(
      GamifyProtocol.contract,
      this.contractId,
      "supernfts"
    ),
    collections: new RalphMap<HexString, boolean>(
      GamifyProtocol.contract,
      this.contractId,
      "collections"
    ),
    approved: new RalphMap<Address, boolean>(
      GamifyProtocol.contract,
      this.contractId,
      "approved"
    ),
  };

  async fetchState(): Promise<GamifyProtocolTypes.State> {
    return fetchContractState(GamifyProtocol, this);
  }

  async getContractEventsCurrentCount(): Promise<number> {
    return getContractEventsCurrentCount(this.address);
  }

  subscribeSuperchargeEvent(
    options: EventSubscribeOptions<GamifyProtocolTypes.SuperchargeEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      GamifyProtocol.contract,
      this,
      options,
      "Supercharge",
      fromCount
    );
  }

  subscribeUpdateEvent(
    options: EventSubscribeOptions<GamifyProtocolTypes.UpdateEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      GamifyProtocol.contract,
      this,
      options,
      "Update",
      fromCount
    );
  }

  subscribeAllEvents(
    options: EventSubscribeOptions<
      GamifyProtocolTypes.SuperchargeEvent | GamifyProtocolTypes.UpdateEvent
    >,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvents(
      GamifyProtocol.contract,
      this,
      options,
      fromCount
    );
  }

  view = {
    getNFTstats: async (
      params: GamifyProtocolTypes.CallMethodParams<"getNFTstats">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"getNFTstats">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "getNFTstats",
        params,
        getContractByCodeHash
      );
    },
    isSupercharged: async (
      params: GamifyProtocolTypes.CallMethodParams<"isSupercharged">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"isSupercharged">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "isSupercharged",
        params,
        getContractByCodeHash
      );
    },
    supercharge: async (
      params: GamifyProtocolTypes.CallMethodParams<"supercharge">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"supercharge">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "supercharge",
        params,
        getContractByCodeHash
      );
    },
    updateLevel: async (
      params: GamifyProtocolTypes.CallMethodParams<"updateLevel">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"updateLevel">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "updateLevel",
        params,
        getContractByCodeHash
      );
    },
    rest: async (
      params: GamifyProtocolTypes.CallMethodParams<"rest">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"rest">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "rest",
        params,
        getContractByCodeHash
      );
    },
    removeHealth: async (
      params: GamifyProtocolTypes.CallMethodParams<"removeHealth">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"removeHealth">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "removeHealth",
        params,
        getContractByCodeHash
      );
    },
    addXp: async (
      params: GamifyProtocolTypes.CallMethodParams<"addXp">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"addXp">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "addXp",
        params,
        getContractByCodeHash
      );
    },
    editValidContract: async (
      params: GamifyProtocolTypes.CallMethodParams<"editValidContract">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"editValidContract">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "editValidContract",
        params,
        getContractByCodeHash
      );
    },
    rewardPaca: async (
      params: GamifyProtocolTypes.CallMethodParams<"rewardPaca">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"rewardPaca">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "rewardPaca",
        params,
        getContractByCodeHash
      );
    },
    updateGamifyCode: async (
      params: GamifyProtocolTypes.CallMethodParams<"updateGamifyCode">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"updateGamifyCode">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "updateGamifyCode",
        params,
        getContractByCodeHash
      );
    },
    updateGamifyFields: async (
      params: GamifyProtocolTypes.CallMethodParams<"updateGamifyFields">
    ): Promise<GamifyProtocolTypes.CallMethodResult<"updateGamifyFields">> => {
      return callMethod(
        GamifyProtocol,
        this,
        "updateGamifyFields",
        params,
        getContractByCodeHash
      );
    },
  };

  transact = {
    getNFTstats: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"getNFTstats">
    ): Promise<GamifyProtocolTypes.SignExecuteMethodResult<"getNFTstats">> => {
      return signExecuteMethod(GamifyProtocol, this, "getNFTstats", params);
    },
    isSupercharged: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"isSupercharged">
    ): Promise<
      GamifyProtocolTypes.SignExecuteMethodResult<"isSupercharged">
    > => {
      return signExecuteMethod(GamifyProtocol, this, "isSupercharged", params);
    },
    supercharge: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"supercharge">
    ): Promise<GamifyProtocolTypes.SignExecuteMethodResult<"supercharge">> => {
      return signExecuteMethod(GamifyProtocol, this, "supercharge", params);
    },
    updateLevel: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"updateLevel">
    ): Promise<GamifyProtocolTypes.SignExecuteMethodResult<"updateLevel">> => {
      return signExecuteMethod(GamifyProtocol, this, "updateLevel", params);
    },
    rest: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"rest">
    ): Promise<GamifyProtocolTypes.SignExecuteMethodResult<"rest">> => {
      return signExecuteMethod(GamifyProtocol, this, "rest", params);
    },
    removeHealth: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"removeHealth">
    ): Promise<GamifyProtocolTypes.SignExecuteMethodResult<"removeHealth">> => {
      return signExecuteMethod(GamifyProtocol, this, "removeHealth", params);
    },
    addXp: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"addXp">
    ): Promise<GamifyProtocolTypes.SignExecuteMethodResult<"addXp">> => {
      return signExecuteMethod(GamifyProtocol, this, "addXp", params);
    },
    editValidContract: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"editValidContract">
    ): Promise<
      GamifyProtocolTypes.SignExecuteMethodResult<"editValidContract">
    > => {
      return signExecuteMethod(
        GamifyProtocol,
        this,
        "editValidContract",
        params
      );
    },
    rewardPaca: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"rewardPaca">
    ): Promise<GamifyProtocolTypes.SignExecuteMethodResult<"rewardPaca">> => {
      return signExecuteMethod(GamifyProtocol, this, "rewardPaca", params);
    },
    updateGamifyCode: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"updateGamifyCode">
    ): Promise<
      GamifyProtocolTypes.SignExecuteMethodResult<"updateGamifyCode">
    > => {
      return signExecuteMethod(
        GamifyProtocol,
        this,
        "updateGamifyCode",
        params
      );
    },
    updateGamifyFields: async (
      params: GamifyProtocolTypes.SignExecuteMethodParams<"updateGamifyFields">
    ): Promise<
      GamifyProtocolTypes.SignExecuteMethodResult<"updateGamifyFields">
    > => {
      return signExecuteMethod(
        GamifyProtocol,
        this,
        "updateGamifyFields",
        params
      );
    },
  };

  async multicall<Calls extends GamifyProtocolTypes.MultiCallParams>(
    calls: Calls
  ): Promise<GamifyProtocolTypes.MultiCallResults<Calls>>;
  async multicall<Callss extends GamifyProtocolTypes.MultiCallParams[]>(
    callss: Narrow<Callss>
  ): Promise<GamifyProtocolTypes.MulticallReturnType<Callss>>;
  async multicall<
    Callss extends
      | GamifyProtocolTypes.MultiCallParams
      | GamifyProtocolTypes.MultiCallParams[]
  >(callss: Callss): Promise<unknown> {
    return await multicallMethods(
      GamifyProtocol,
      this,
      callss,
      getContractByCodeHash
    );
  }
}
